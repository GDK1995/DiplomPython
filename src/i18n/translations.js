export default {
    ru: {
        title_1: 'Ввод и вывод данных',
        text_1: 'Для печати значений в Питоне есть функция print(). Внутри круглых скобок через запятую мы пишем то, что хотим вывести. Вот программа, которая делает несколько вычислений: print(5 + 10)',
        text_1_1: 'Для ввода данных в программу мы используем функцию input(). Она считывает одну строку.',
        text_1_2: 'Вот программа, которая считывает имя пользователя и приветствует его: ',
        text_1_3: 'print("Как вас зовут?")',
        text_1_4: 'name = input()',
        text_1_5: 'print("Здравствуйте, " + name + "!")',
        text_1_6: 'Мы будем писать программы, которые считывают данные, перерабатывают их и выводят какой-то результат. При запуске на компьютере такие программы считывают данные, которые пользователь вводит с клавиатуры, а результат выводят на экран.',
        text_1_7: 'Попробуем написать программу, которая считывает два числа и выводит их сумму. Для этого считаем два числа и сохраним их в переменные a и b, пользуясь оператором присваивания =. Слева от оператора присваивания в программах на Питоне ставится имя переменной — например, строка из латинских букв. Справа от оператора присваивания ставится любое выражение. Имя станет указывать на результат вычисления выражения. Проиграйте эту программу и посмотрите на результаты её работы:',
        text_1_8: 'a = input()',
        text_1_9: 'b = input()',
        text_1_10: 's = a + b',
        text_1_11: 'print(s)',
        text_1_12: 'Мы видим, что программа выводит 57, хотя в реальной жизни 5 + 7 будет 12. Это произошло потому, что Питон в третьей строчке «сложил» две строки, а не два числа. В Питоне две строки складываются так: к первой строке приписывается вторая.',
        text_1_13: 'Обратите внимание, что в визуализаторе содержимое переменных a и b заключено в кавычки. Это означает, что в a и b лежат строки, а не числа.',
        text_1_14: 'В Питоне все данные называются объектами. Число 2 представляется объектом «число 2», строка "hello" – это объект «строка "hello"».',
        text_1_15: 'Каждый объект относится к какому-то типу. Строки хранятся в объектах типа str, целые числа хранятся в объектах типа int, дробные числа (вещественные числа) — в объектах типа float. Тип объекта определяет, какие действия можно делать с объектами этого типа.',
        chapter_2_1: 'Синтаксис условной инструкции',
        chapter_2_2: 'Вложенные условные инструкции',
        chapter_2_3: 'Операторы сравнения',
        chapter_2_4: 'Тип данных bool',
        chapter_2_5: 'Каскадные условные инструкции',
        title_2: 'Условия',
        text_2_1: 'Все ранее рассматриваемые программы имели линейную структуру: все инструкции выполнялись последовательно одна за одной, каждая записанная инструкция обязательно выполняется.',
        text_2_2: 'Внутри условных инструкций можно использовать любые инструкции языка Питон, в том числе и условную инструкцию. Получаем вложенное ветвление – после одной развилки в ходе исполнения программы появляется другая развилка. При этом вложенные блоки имеют больший размер отступа (например, 8 пробелов).',
        text_2_3: 'Операторы сравнения в Питоне можно объединять в цепочки (в отличии от большинства других языков программирования, где для этого нужно использовать логические связки',
        text_2_4: 'Операторы сравнения возвращают значения специального логического типа bool. Значения логического типа могут принимать одно из двух значений: True (истина) или False (ложь).',
        text_2_5: 'Если преобразовать логическое True к типу int, то получится 1, а преобразование False даст 0. При обратном преобразовании число 0 преобразуется в False, а любое ненулевое число в True. При преобразовании str в bool пустая строка преобразовывается в False, а любая непустая строка в True.',
        text_2_6: 'Допустим мы хотим по данному числу x определить его абсолютную величину (модуль). Программа должна напечатать значение переменной x, если x>0 или же величину -x в противном случае. Линейная структура программы нарушается: в зависимости от справедливости условия x>0 должна быть выведена одна или другая величина. Соответствующий фрагмент программы на Питоне имеет вид:',
        text_2_7: 'x = int(input())',
        text_2_8: 'if x > 0:',
        text_2_9: 'print(x)',
        text_2_10: 'else:',
        text_2_11: 'print(-x)',
        text_2_12: 'В этой программе используется условная инструкция if (если). После слова if указывается проверяемое условие (x > 0), завершающееся двоеточием. После этого идет блок (последовательность) инструкций, который будет выполнен, если условие истинно, в нашем примере это вывод на экран величины x. Затем идет слово else (иначе), также завершающееся двоеточием, и блок инструкций, который будет выполнен, если проверяемое условие неверно, в данном случае будет выведено значение -x.',
        text_2_13: 'Итак, условная инструкция в Питоне имеет следующий синтаксис:',
        text_2_14: 'if Условие:',
        text_2_15: 'Блок инструкций 1',
        text_2_16: 'else:',
        text_2_17: 'Блок инструкций 2',
        text_2_18: 'Блок инструкций 1 будет выполнен, если Условие истинно. Если Условие ложно, будет выполнен Блок инструкций 2.',
        text_2_19: 'Для выделения блока инструкций, относящихся к инструкции if или else в языке Питон используются отступы. Все инструкции, которые относятся к одному блоку, должны иметь равную величину отступа, то есть одинаковое число пробелов в начале строки. Рекомендуется использовать отступ в 4 пробела и не рекомедуется использовать в качестве отступа символ табуляции.',
        text_2_20: 'Это одно из существенных отличий синтаксиса Питона от синтаксиса большинства языков, в которых блоки выделяются специальными словами, например, нц... кц в Кумире, begin... end в Паскале или фигурными скобками в Си.',
        text_2_21: 'Покажем это на примере программы, которая по данным ненулевым числам x и y определяет, в какой из четвертей координатной плоскости находится точка (x,y):',
        text_2_22: 'В этом примере мы использовали комментарии – текст, который интерпретатор игнорирует. Комментариями в Питоне является символ # и весь текст после этого символа до конца строки.',
        text_2_23: 'Меньше — условие верно, если первый операнд меньше второго.',
        text_2_24: 'Больше — условие верно, если первый операнд больше второго.',
        text_2_25: 'Меньше или равно.',
        text_2_26: 'Больше или равно.',
        text_2_27: 'Равенство. Условие верно, если два операнда равны.',
        text_2_28: 'Неравенство. Условие верно, если два операнда неравны.',
        text_2_29: 'Например, условие (x * x < 1000) означает “значение x * x меньше 1000”, а условие (2 * x != y) означает “удвоенное значение переменной x не равно значению переменной y”.',
        text_2_30: 'Операторы сравнения в Питоне можно объединять в цепочки (в отличии от большинства других языков программирования, где для этого нужно использовать логические связки), например, a == b == c или 1 <= x <= 10.',
        text_2_31: 'Иногда нужно проверить одновременно не одно, а несколько условий. Например, проверить, является ли данное число четным можно при помощи условия (n % 2 == 0) (остаток от деления n на 2 равен 0), а если необходимо проверить, что два данных целых числа n и m являются четными, необходимо проверить справедливость обоих условий: n % 2 == 0 и m % 2 == 0, для чего их необходимо объединить при помощи оператора and (логическое И): n % 2 == 0 and m % 2 == 0.',
        text_2_32: 'В Питоне существуют стандартные логические операторы: логическое И, логическое ИЛИ, логическое отрицание.',
        text_2_33: 'Логическое И является бинарным оператором (то есть оператором с двумя операндами: левым и правым) и имеет вид and. Оператор and возвращает True тогда и только тогда, когда оба его операнда имеют значение True.',
        text_2_34: 'Логическое ИЛИ является бинарным оператором и возвращает True тогда и только тогда, когда хотя бы один операнд равен True. Оператор “логическое ИЛИ” имеет вид or.',
        text_2_35: 'Логическое НЕ (отрицание) является унарным (то есть с одним операндом) оператором и имеет вид not, за которым следует единственный операнд. Логическое НЕ возвращает True, если операнд равен False и наоборот.',
        text_2_36: 'Пример программы, определяющий четверть координатной плоскости, можно переписать используя “каскадную“ последовательность операцией if... elif... else:',
        text_2_37: 'В такой конструкции условия if, ..., elif проверяются по очереди, выполняется блок, соответствующий первому из истинных условий. Если все проверяемые условия ложны, то выполняется блок else, если он присутствует.',
        title_3: 'Вычисления',
        chapter_3_1: 'Целочисленная арифметика',
        chapter_3_2: 'Действительные числа',
        chapter_3_3: 'Библиотека math',
        text_3_1: 'Для целых чисел определены операции +, -, * и **. Операция деления / для целых чисел возвращает вещественное число (значение типа float). Также функция возведения в степень возвращает значение типа float, если показатель степени — отрицательное число.',
        text_3_2: 'В этом разделе речь пойдет о действительных числах, имеющих тип float. Обратите внимание, что если вы хотите считать с клавиатуры действительное число, то результат, возращаемый функцией input() необходимо преобразовывать к типу float:',
        text_3_3: 'Для проведения вычислений с действительными числами язык Питон содержит много дополнительных функций, собранных в библиотеку (модуль), которая называется math.',
        text_3_4: 'Но есть и специальная операция целочисленного деления, выполняющегося с отбрасыванием дробной части, которая обозначается // (она соответствует операции div в Паскале). Она возвращает целое число: целую часть частного. Другая близкая ей операция − это операция взятия остатка от деления, обозначаемая % (она соответствует операции mod в Паскале). Например:',
        text_3_5: 'print(17 / 3)   # выведет 5.66666666667',
        text_3_6: 'print(17 // 3)  # выведет 5',
        text_3_7: 'print(17 % 3)   # выведет 2',
        text_3_8: 'x = float(input())',
        text_3_9: 'print(x)',
        text_3_10: 'Действительные (вещественные) числа представляются в виде чисел с десятичной точкой (а не запятой, как принято при записи десятичных дробей в русских текстах). Для записи очень больших или очень маленьких по модулю чисел используется так называемая запись «с плавающей точкой» (также называемая «научная» запись). В этом случае число представляется в виде некоторой десятичной дроби, называемой мантиссой, умноженной на целочисленную степень десяти (порядок). Например, расстояние от Земли до Солнца равно 1.496·1011, а масса молекулы воды 2.99·10-23.',
        text_3_11: 'Числа с плавающей точкой в программах на языке Питон, а также при вводе и выводе записываются так: сначала пишется мантисса, затем пишется буква e, затем пишется порядок. Пробелы внутри этой записи не ставятся. Например, указанные выше константы можно записать в виде 1.496e11 и 2.99e-23. Перед самим числом также может стоять знак минус.',
        text_3_12: 'Напомним, что результатом операции деления / всегда является действительное число (float), в то время как результатом операции // является целое число (int).',
        text_3_13: 'Для использования этих функций в начале программы необходимо подключить математическую библиотеку, что делается командой',
        text_3_14: 'import math',
        text_3_15: 'Например, пусть мы хотим округлять вещественные числа до ближайшего целого числа вверх. Соответствующая функция ceil от одного аргумента вызывается, например, так: math.ceil(x) (то есть явно указывается, что из модуля math используется функция ceil). Вместо числа x может быть любое число, переменная или выражение.',
        title_4: 'Цикл for',
        chapter_4_1: 'Цикл for',
        chapter_4_2: 'Функция range',
        chapter_4_3: 'Настройка функции print()',
        text_4_1: 'Цикл for, также называемый циклом с параметром, в языке Питон богат возможностями. В цикле for указывается переменная и множество значений, по которому будет пробегать переменная. Множество значений может быть задано списком, кортежем, строкой или диапазоном.',
        text_4_2: 'Как правило, циклы for используются либо для повторения какой-либо последовательности действий заданное число раз, либо для изменения значения переменной в цикле от некоторого начального значения до некоторого конечного.',
        text_4_3: 'По умолчанию функция print() принимает несколько аргументов, выводит их через пробел, после чего ставит перевод строки. Это поведение можно изменить, используя именованные параметры sep (разделитель) и end (окончание).',
        text_4_4: 'print(4, 5, 6)',
        text_4_5: 'print()',
        text_4_6: 'Для повторения цикла некоторое заданное число раз n можно использовать цикл for вместе с функцией range:',
        text_4_7: 'for i in range(4):  # равносильно инструкции for i in 0, 1, 2, 3:',
        text_4_8: '# здесь можно выполнять циклические действия',
        text_4_9: 'print(i)',
        text_4_10: 'print(i ** 2)',
        text_4_11: '# цикл закончился, поскольку закончился блок с отступом',
        text_4_12: 'print("Конец цикла")',
        text_4_13: 'В качестве n может использоваться числовая константа, переменная или произвольное арифметическое выражение (например, 2 ** 10). Если значение n равно нулю или отрицательное, то тело цикла не выполнится ни разу.',
        text_4_14: 'Функция range может также принимать не один, а два параметра. Вызов range(a, b) означает, что индексная переменная будеть принимать значения от a до b - 1, то есть первый параметр функции range, вызываемой с двумя параметрами, задает начальное значение индексной переменной, а второй параметр — первое значение, которое индексная переменная принимать не будет.',
        text_4_15: 'Наконец, чтобы организовать цикл, в котором индексная переменная будет уменьшаться, необходимо использовать функцию range с тремя параметрами. Первый параметр задает начальное значение индексной переменной, второй параметр — значение, до которого будет изменяться индексная переменная (не включая его!), а третий параметр — величину изменения индексной переменной. Например, сделать цикл по всем нечетным числам от 1 до 99 можно при помощи функции range(1, 100, 2), а сделать цикл по всем числам от 100 до 1 можно при помощи range(100, 0, -1).',
        text_4_16: 'Вот простейший пример использования цикла, где в качестве множества значений используется кортеж:',
        text_4_17: 'Инструкция i += 1 эквивалентна конструкции i = i + 1 (это просто сокращенная запись). Такую сокращенную запись можно использовать для всех арифметических операций: *=, -=, /=, %=...',
        text_4_18: 'При первых трех итерациях цикла переменная i будет принимать значение типа int, при последующих трех — типа str.',
        title_5: 'Строки',
        chapter_5_1: 'Срезы (slices)',
        chapter_5_2: 'Методы',
        text_5_1: 'Строка считывается со стандартного ввода функцией input(). Напомним, что для двух строк определена операция сложения (конкатенации), также определена операция умножения строки на число.',
        text_5_2: 'Срез (slice) — извлечение из данной строки одного символа или некоторого фрагмента подстроки или подпоследовательности.',
        text_5_3: 'Метод — это функция, применяемая к объекту, в данном случае — к строке. Метод вызывается в виде Имя_объекта.Имя_метода(параметры). Например, S.find("e") — это применение к строке S метода find с одним параметром "e".',
        text_5_4: 'Строка состоит из последовательности символов. Узнать количество символов (длину строки) можно при помощи функции len.',
        text_5_5: 'Любой другой объект в Питоне можно перевести к строке, которая ему соответствует. Для этого нужно вызвать функцию str(), передав ей в качестве параметра объект, переводимый в строку.',
        text_5_6: 'На самом деле каждая строка, с точки зрения Питона, — это объект класса str. Чтобы получить по объекту другой объект другого класса, как-то ему соответствующий, можно использовать функцию приведения. Имя этой функции совпадает с именем класса, к которому мы приводим объект. (Для знатоков: эта функция — это конструктор объектов данного класса.) Пример: int — класс для целых чисел. Перевод строки в число осуществляется функцией int().',
        text_5_7: 'Заметим, что в Питоне нет отдельного типа для символов строки. Каждый объект, который получается в результате среза S[i] — это тоже строка типа str.',
        text_5_8: 'Номера символов в строке (а также в других структурах данных: списках, кортежах) называются индексом.',
        text_5_9: 'Срез с двумя параметрами: S[a:b] возвращает подстроку из b - a символов, начиная с символа c индексом a, то есть до символа с индексом b, не включая его. Например, S[1:4] == "ell", то же самое получится если написать S[-4:-1]. Можно использовать как положительные, так и отрицательные индексы в одном срезе, например, S[1:-1] — это строка без первого и последнего символа (срез начинается с символа с индексом 1 и заканчиватеся индексом -1, не включая его).',
        text_5_10: 'Если опустить второй параметр (но поставить двоеточие), то срез берется до конца строки. Например, чтобы удалить из строки первый символ (его индекс равен 0), можно взять срез S[1:]. Аналогично если опустить первый параметр, то можно взять срез от начала строки. То есть удалить из строки последний символ можно при помощи среза S[:-1]. Срез S[:] совпадает с самой строкой S.',
        text_5_11: 'Любые операции среза со строкой создают новые строки и никогда не меняют исходную строку. В Питоне строки вообще являются неизменяемыми, их невозможно изменить. Можно лишь в старую переменную присвоить новую строку.',
        text_5_12: 'На самом деле в питоне нет и переменных. Есть лишь имена, которые связаны с какими-нибудь объектами. Можно сначала связать имя с одним объектом, а потом — с другим. Можно несколько имён связать с одним и тем же объектом.',
        text_5_13: 'Если задать срез с тремя параметрами S[a:b:d], то третий параметр задает шаг, как в случае с функцией range, то есть будут взяты символы с индексами a, a + d, a + 2 * d и т. д. При задании значения третьего параметра, равному 2, в срез попадет кажый второй символ, а если взять значение среза, равное -1, то символы будут идти в обратном порядке. Например, можно перевернуть строку срезом S[::-1].',
        text_5_14: 'Метод find находит в данной строке (к которой применяется метод) данную подстроку (которая передается в качестве параметра). Функция возвращает индекс первого вхождения искомой подстроки. Если же подстрока не найдена, то метод возвращает значение -1.',
        text_5_15: 'Аналогично, метод rfind возвращает индекс последнего вхождения данной строки (“поиск справа”).',
        text_5_16: 'Если вызвать метод find с тремя параметрами S.find(T, a, b), то поиск будет осуществляться в срезе S[a:b]. Если указать только два параметра S.find(T, a), то поиск будет осуществляться в срезе S[a:], то есть начиная с символа с индексом a и до конца строки. Метод S.find(T, a, b) возращает индекс в строке S, а не индекс относительно среза.',
        text_5_17: 'Метод replace заменяет все вхождения одной строки на другую. Формат: S.replace(old, new) — заменить в строке S все вхождения подстроки old на подстроку new.',
        text_5_18: 'Подсчитывает количество вхождений одной строки в другую строку. Простейшая форма вызова S.count(T)  возвращает число вхождений строки T внутри строки S. ',
        title_6: 'Цикл while',
        chapter_6_1: 'Инструкции управления циклом',
        chapter_6_2: 'Множественное присваивание',
        text_6_1: 'Цикл while (“пока”) позволяет выполнить одну и ту же последовательность действий, пока проверяемое условие истинно. Условие записывается до тела цикла и проверяется до выполнения тела цикла. Как правило, цикл while используется, когда невозможно определить точное значение количества проходов исполнения цикла.',
        text_6_2: 'После тела цикла можно написать слово else: и после него блок операций, который будет выполнен один раз после окончания цикла, когда проверяемое условие станет неверно',
        text_6_3: 'Отличие двух способов состоит в том, что множественное присваивание в первом способе меняет значение двух переменных одновременно. Если слева от знака «=» в множественном присваивании должны стоять через запятую имена переменных, то справа могут стоять произвольные выражения, разделённые запятыми. Главное, чтобы слева и справа от знака присваивания было одинаковое число элементов.',
        text_6_4: 'При выполнении цикла while сначала проверяется условие. Если оно ложно, то выполнение цикла прекращается и управление передается на следующую инструкцию после тела цикла while. Если условие истинно, то выполняется инструкция, после чего условие проверяется снова и снова выполняется инструкция. Так продолжается до тех пор, пока условие будет истинно. Как только условие станет ложно, работа цикла завершится и управление передастся следующей инструкции после цикла.',
        text_6_5: 'Например, следующий фрагмент программы напечатает на экран квадраты всех целых чисел от 1 до 10. Видно, что цикл while может заменять цикл for ... in range(...):',
        text_6_6: 'В этом примере переменная i внутри цикла изменяется от 1 до 10. Такая переменная, значение которой меняется с каждым новым проходом цикла, называется счетчиком. Заметим, что после выполнения этого фрагмента значение переменной i будет равно 11, поскольку именно при i == 11 условие i <= 10 впервые перестанет выполняться.',
        text_6_7: 'Казалось бы, никакого смысла в этом нет, ведь эту же инструкцию можно просто написать после окончания цикла. Смысл появляется только вместе с инструкцией break. Если во время выполнения Питон встречает инструкцию break внутри цикла, то он сразу же прекращает выполнение этого цикла и выходит из него. При этом ветка else исполняться не будет. Разумеется, инструкцию break осмыленно вызывать только внутри инструкции if, то есть она должна выполняться только при выполнении какого-то особенного условия.',
        text_6_8: 'Приведем пример программы, которая считывает числа до тех пор, пока не встретит отрицательное число. При появлении отрицательного числа программа завершается. В первом варианте последовательность чисел завершается числом 0 (при считывании которого надо остановиться).',
        text_6_9: 'Во втором варианте программы сначала на вход подается количество элементов последовательности, а затем и сами элементы. В таком случае удобно воспользоваться циклом for. Цикл for также может иметь ветку else и содержать инструкции break внутри себя.',
        text_6_10: 'Отличие двух способов состоит в том, что множественное присваивание в первом способе меняет значение двух переменных одновременно. Если слева от знака «=» в множественном присваивании должны стоять через запятую имена переменных, то справа могут стоять произвольные выражения, разделённые запятыми. Главное, чтобы слева и справа от знака присваивания было одинаковое число элементов.',
        text_6_11: 'Множественное присваивание удобно использовать, когда нужно обменять значения двух переменных.',
        title_7: 'Списки',
        chapter_7_1: 'Методы split и join',
        chapter_7_2: 'Генераторы списков',
        chapter_7_3: 'Срезы',
        text_7_1: 'Большинство программ работает не с отдельными переменными, а с набором переменных. Например, программа может обрабатывать информацию об учащихся класса, считывая список учащихся с клавиатуры или из файла, при этом изменение количества учащихся в классе не должно требовать модификации исходного кода программы. Раньше мы сталкивались с задачей обработки элементов последовательности, например, вычисляя наибольший элемент последовательности. Но при этом мы не сохраняли всю последовательность в памяти компьютера. Однако, во многих задачах нужно именно сохранять всю последовательность, например, если бы нам требовалось вывести все элементы последовательности в возрастающем порядке (“отсортировать последовательность”). Для хранения таких данных можно использовать структуру данных, называемую в Питоне список (в большинстве же языков программирования используется другой термин “массив”). Список представляет собой последовательность элементов, пронумерованных от 0, как символы в строке. Список можно задать перечислением элементов списка в квадратных скобках, например, список можно задать так:',
        text_7_2: 'Элементы списка могут вводиться по одному в строке, в этом случае строку целиком можно считать функцией input(). После этого можно использовать метод строки split(), возвращающий список строк, которые получатся, если исходную строку разрезать на части по пробелам.',
        text_7_3: 'Для создания списков, заполненных по более сложным формулам можно использовать генераторы: выражения, позволяющие заполнить список некоторой формулой. ',
        text_7_4: 'Списки, в отличии от строк, являются изменяемыми объектами: можно отдельному элементу списка присвоить новое значение. Но можно менять и целиком срезы.',
        title_8: 'Функции и рекурсия',
        chapter_8_1: 'Функции',
        chapter_8_2: 'Локальные и глобальные переменные',
        chapter_8_3: 'Рекурсия',
        text_8_1: 'Напомним, что в математике факториал числа n определяется как n! = 1 ⋅ 2 ⋅ ... ⋅ n. Например, 5! = 1 ⋅ 2 ⋅ 3 ⋅ 4 ⋅ 5 = 120. Ясно, что факториал можно легко посчитать, воспользовавшись циклом for. Представим, что нам нужно в нашей программе вычислять факториал разных чисел несколько раз (или в разных местах кода). Конечно, можно написать вычисление факториала один раз, а затем используя Copy-Paste вставить его везде, где это будет нужно.',
        text_8_2: 'Здесь переменной a присваивается значение 1, и функция f() печатает это значение, несмотря на то, что до объявления функции f эта переменная не инициализируется. В момент вызова функции f() переменной a уже присвоено значение, поэтому функция f() может вывести его на экран.',
        text_8_3: 'Как мы видели выше, функция может вызывать другую функцию. Но функция также может вызывать и саму себя! Рассмотрим это на примере функции вычисления факториала. Хорошо известно, что 0!=1, 1!=1. А как вычислить величину n! для большого n? Если бы мы могли вычислить величину (n-1)!, то тогда мы легко вычислим n!, поскольку n!=n⋅(n-1)!. Но как вычислить (n-1)!? Если бы мы вычислили (n-2)!, то мы сможем вычисли и (n-1)!=(n-1)⋅(n-2)!. А как вычислить (n-2)!? Если бы... В конце концов, мы дойдем до величины 0!, которая равна 1. Таким образом, для вычисления факториала мы можем использовать значение факториала для меньшего числа. ',
        title_9: 'Двумерные массивы',
        chapter_9_1: 'Обработка и вывод вложенных списков',
        chapter_9_2: 'Создание вложенных списков',
        chapter_9_3: 'Ввод двумерного массива',
        chapter_9_4: 'Пример обработки двумерного массива',
        chapter_9_5: 'Вложенные генераторы двумерных массивов',
        text_9_1: 'Часто в задачах приходится хранить прямоугольные таблицы с данными. Такие таблицы называются матрицами или двумерными массивами. В языке программирования Питон таблицу можно представить в виде списка строк, каждый элемент которого является в свою очередь списком, например, чисел. Например, приведём программу, в которой создаётся числовая таблица из двух строк и трех столбцов, с которой производятся различные действия.',
        text_9_2: 'В этом легко убедиться, если присвоить элементу a[0][0] значение 5, а потом вывести значение другого элемента a[1][0] — оно тоже будет равно 5. Дело в том, что [0] * m возвращает ccылку на список из m нулей. Но последующее повторение этого элемента создает список из n элементов, которые являются ссылкой на один и тот же список (точно так же, как выполнение операции b = a для списков не создает новый список), поэтому все строки результирующего списка на самом деле являются одной и той же строкой.',
        text_9_3: 'Пусть программа получает на вход двумерный массив в виде n строк, каждая из которых содержит m чисел, разделенных пробелами.',
        text_9_4: 'Пусть дан квадратный массив из n строк и n столбцов. Необходимо элементам, находящимся на главной диагонали, проходящей из левого верхнего угла в правый нижний (то есть тем элементам a[i][j], для которых i==j) присвоить значение 1, элементам, находящимся выше главной диагонали – значение 0, элементам, находящимся ниже главной диагонали – значение 2.',
        text_9_5: 'Для создания двумерных массивов можно использовать вложенные генераторы, разместив генератор списка, являющегося строкой, внутри генератора всех строк. Напомним, что сделать список из n строк и m столбцов можно при помощи генератора, создающего список из n элементов, каждый элемент которого является списком из m нулей',
        title_10: 'Множества',
        text_10: 'Множество в языке Питон — это структура данных, эквивалентная множествам в математике. Множество может состоять из различных элементов, порядок элементов в множестве неопределен. В множество можно добавлять и удалять элементы, можно перебирать элементы множества, можно выполнять операции над множествами (объединение, пересечение, разность). Можно проверять принадлежность элемента множеству.',
        title_11: 'Словари',
        text_11: 'Обычные списки (массивы) представляют собой набор пронумерованных элементов, то есть для обращения к какому-либо элементу списка необходимо указать его номер. Номер элемента в списке однозначно идентифицирует сам элемент. Но идентифицировать данные по числовым номерам не всегда оказывается удобно. Например, маршруты поездов в России идентифицируются численно-буквенным кодом (число и одна буква), также численно-буквенным кодом идентифицируются авиарейсы, то есть для хранения информации о рейсах поездов или самолетов в качестве идентификатора удобно было бы использовать не число, а текстовую строку.',
        user_1: 'Преподаватели',
        user_2: 'Студенты',
        user_3: 'Администраторы',
        add_admin: 'Добавить администратора',
        add_teacher: 'Добавить преподавателя',
        add_student: 'Добавить студента',
        test_1: 'Основы программирования на Python',
        test_1_1: 'Тест по темам: ввод-вывод данных, целочисленная арифметика, условный оператор if, цикл for',
        test_2: 'Циклы в Python',
        test_2_1: 'Проверка умения чтения программного кода. Сложность вопросов средняя.',
        test_3: 'Заполнение и вывод массива в Python',
        test_3_1: 'Для работы с большим количеством однотипных данных используются массивы.',
        test_4: 'Итерации в Python',
        test_4_1: 'Проверочная работа по информатике для учащихся 9 классов по раздел: Программирование на языке Python',
        test_5: '',
        test_5_1: 'Тест содержит 30 вопросов по теме "Программирование на языке Python"',
        test_6: '',
        test_7: '',
        practice_page: 'Практическая работа',
        practice_1: 'Напишите программу, которая считывает три числа и выводит их сумму. Каждое число записано в отдельной строке.',
        practice_2: 'Напишите программу, которая считывает длины двух катетов в прямоугольном треугольнике и выводит его площадь.',
        practice_3: 'n школьников делят k яблок поровну, неделящийся остаток остается в корзинке. Сколько яблок достанется каждому школьнику? Сколько яблок останется в корзинке? Программа получает на вход числа n и k и должна вывести искомое количество яблок (два числа).',
        practice_4: 'Дано число n. С начала суток прошло n минут. Определите, сколько часов и минут будут показывать электронные часы в этот момент. Программа должна вывести два числа: количество часов (от 0 до 23) и количество минут (от 0 до 59). Учтите, что число n может быть больше, чем количество минут в сутках.',
        practice_5: 'В школе решили набрать три новых математических класса. Так как занятия по математике у них проходят в одно и то же время, было решено выделить кабинет для каждого класса и купить в них новые парты. За каждой партой может сидеть не больше двух учеников. Известно количество учащихся в каждом из трёх классов. Сколько всего нужно закупить парт чтобы их хватило на всех учеников? Программа получает на вход три натуральных числа: количество учащихся в каждом из трех классов.',
        practice_6: 'Даны два целых числа. Выведите значение наименьшего из них.',
        practice_7: 'Даны три целых числа. Выведите значение наименьшего из них.',
        practice_8: 'Даны три целых числа. Определите, сколько среди них совпадающих. Программа должна вывести одно из чисел: 3 (если все совпадают), 2 (если два совпадает) или 0 (если все числа различны).',
        practice_9: 'Шахматный ферзь ходит по диагонали, горизонтали или вертикали. Даны две различные клетки шахматной доски, определите, может ли ферзь попасть с первой клетки на вторую одним ходом.',
        practice_10: 'Шоколадка имеет вид прямоугольника, разделенного на n×m долек. Шоколадку можно один раз разломить по прямой на две части. Определите, можно ли таким образом отломить от шоколадки часть, состоящую ровно из k долек. Программа получает на вход три числа: n, m, k и должна вывести YES или NO.',
        practice_11: 'Дано натуральное число. Выведите его последнюю цифру.',
        practice_12: 'Дано положительное действительное число X. Выведите его дробную часть.',
        practice_13: 'Пирожок в столовой стоит a рублей и b копеек. Определите, сколько рублей и копеек нужно заплатить за n пирожков. Программа получает на вход три числа: a, b, n, и должна вывести два числа: стоимость покупки в рублях и копейках.',
        practice_14: 'Процентная ставка по вкладу составляет P процентов годовых, которые прибавляются к сумме вклада. Вклад составляет X рублей Y копеек. Определите размер вклада через год. Программа получает на вход целые числа P, X, Y и должна вывести два числа: величину вклада через год в рублях и копейках. Дробная часть копеек отбрасывается.',
        practice_15: 'За день машина проезжает n километров. Сколько дней нужно, чтобы проехать маршрут длиной m километров? Программа получает на вход числа n и m.',
        practice_16: 'Даны два целых числа A и B (при этом A ≤ B). Выведите все числа от A до B включительно.',
        practice_17: 'Даны два целых числа A и В. Выведите все числа от A до B включительно, в порядке возрастания, если A < B, или в порядке убывания в противном случае.',
        practice_18: 'Дано N чисел: сначала вводится число N, затем вводится ровно N целых чисел. Подсчитайте количество нулей среди введенных чисел и выведите это количество. Вам нужно подсчитать количество чисел, равных нулю, а не количество цифр.',
        practice_19: 'По данному натуральному n ≤ 9 выведите лесенку из n ступенек, i-я ступенька состоит из чисел от 1 до i без пробелов.',
        practice_20: 'Даны два целых числа A и В, A>B. Выведите все нечётные числа от A до B включительно, в порядке убывания. В этой задаче можно обойтись без инструкции if.',
        practice_21: 'Дана строка, состоящая из слов, разделенных пробелами. Определите, сколько в ней слов. Используйте для решения задачи метод count.',
        practice_22: 'Дана строка. Разрежьте ее на две равные части (если длина строки — четная, а если длина строки нечетная, то длина первой части должна быть на один символ больше). Переставьте эти две части местами, результат запишите в новую строку и выведите на экран.',
        practice_23: 'Дана строка, состоящая ровно из двух слов, разделенных пробелом. Переставьте эти слова местами. Результат запишите в строку и выведите получившуюся строку.',
        practice_24: 'Дана строка. Удалите из нее все символы, чьи индексы делятся на 3.',
        practice_25: 'Дана строка. Замените в этой строке все появления буквы h на букву H, кроме первого и последнего вхождения.',
        practice_26: 'Дано целое число, не меньшее 2. Выведите его наименьший натуральный делитель, отличный от 1.',
        practice_27: 'Определите сумму всех элементов последовательности, завершающейся числом 0. В этой и во всех следующих задачах числа, следующие за первым нулем, учитывать не нужно.',
        practice_28: 'Определите количество четных элементов в последовательности, завершающейся числом 0.',
        practice_29: 'Дана последовательность натуральных чисел, завершающаяся числом 0. Определите, какое наибольшее число подряд идущих элементов этой последовательности равны друг другу.',
        practice_30: 'Последовательность состоит из различных натуральных чисел и завершается числом 0. Определите значение второго по величине элемента в этой последовательности. Гарантируется, что в последовательности есть хотя бы два элемента.',
        practice_31: 'Дан список чисел. Если в нем есть два соседних элемента одного знака, выведите эти числа. Если соседних элементов одного знака нет — не выводите ничего. Если таких пар соседей несколько — выведите первую пару.',
        practice_32: 'Дан список чисел. Определите, сколько в этом списке элементов, которые больше двух своих соседей, и выведите количество таких элементов. Крайние элементы списка никогда не учитываются, поскольку у них недостаточно соседей.',
        practice_33: 'Дан список, упорядоченный по неубыванию элементов в нем. Определите, сколько в нем различных элементов.',
        practice_34: 'Дан список чисел. Посчитайте, сколько в нем пар элементов, равных друг другу. Считается, что любые два элемента, равные друг другу образуют одну пару, которую необходимо посчитать.',
        practice_35: 'Дан список. Выведите те его элементы, которые встречаются в списке только один раз. Элементы нужно выводить в том порядке, в котором они встречаются в списке.',
        practice_36: 'Напишите функцию capitalize(), которая принимает слово из маленьких латинских букв и возвращает его же, меняя первую букву на большую. Например, print(capitalize(word)) должно печатать слово Word.',
        practice_37: 'Дано действительное положительное число a и целоe число n. Вычислите an. Решение оформите в виде функции power(a, n). Стандартной функцией возведения в степень пользоваться нельзя.',
        practice_38: 'Напишите функцию fib(n), которая по данному целому неотрицательному n возвращает n-e число Фибоначчи. В этой задаче нельзя использовать циклы — используйте рекурсию.',
        practice_39: 'Дана последовательность целых чисел, заканчивающаяся числом 0. Выведите эту последовательность в обратном порядке. При решении этой задачи нельзя пользоваться массивами и прочими динамическими структурами данных. Рекурсия вам поможет.',
        practice_40: 'Найдите индексы первого вхождения максимального элемента. Выведите два числа: номер строки и номер столбца, в которых стоит наибольший элемент в двумерном массиве. Если таких элементов несколько, то выводится тот, у которого меньше номер строки, а если номера строк равны то тот, у которого меньше номер столбца.',
        practice_41: 'Дано число n. Создайте массив размером n×n и заполните его по следующему правилу. На главной диагонали должны быть записаны числа 0. На двух диагоналях, прилегающих к главной, числа 1. На следующих двух диагоналях числа 2, и т.д.',
        practice_42: 'Дан двумерный массив и два числа: i и j. Поменяйте в массиве столбцы с номерами i и j и выведите результат.',
        practice_43: 'Даны два числа n и m. Создайте двумерный массив размером n×m и заполните его символами "." и "*" в шахматном порядке. В левом верхнем углу должна стоять точка.',
        practice_44: 'Дано нечетное число n. Создайте двумерный массив из n×n элементов, заполнив его символами "." (каждый элемент массива является строкой из одного символа). Затем заполните символами "*" среднюю строку массива, средний столбец массива, главную диагональ и побочную диагональ. В результате единицы в массиве должны образовывать изображение звездочки. Выведите полученный массив на экран, разделяя элементы массива пробелами.',
        practice_45: 'Дан список чисел. Определите, сколько в нем встречается различных чисел.',
        practice_46: 'Даны два списка чисел. Посчитайте, сколько чисел содержится одновременно как в первом списке, так и во втором.',
        practice_47: 'Дан текст: в первой строке записано число строк, далее идут сами строки. Определите, сколько различных слов содержится в этом тексте. Словом считается последовательность непробельных символов идущих подряд, слова разделены одним или большим числом пробелов или символами конца строки.',
        practice_48: 'Каждый из некоторого множества школьников некоторой школы знает некоторое количество языков. Нужно определить сколько языков знают все школьники, и сколько языков знает хотя бы один из школьников. В первой строке выведите количество языков, которые знают все школьники. Начиная со второй строки - список таких языков. Затем - количество языков, которые знает хотя бы один школьник, на следующих строках - список таких языков. Языки нужно выводить в лексикографическом порядке, по одному на строке.',
        tests_1: 'Какая из следующих функций преобразует строку в список в Python?',
        tests_2: 'list(mystring)',
        tests_3: 'tuple(mystring)',
        tests_4: 'eval(mystring)',
        tests_5: 'repr(mystring)',
        tests_6: 'Какая из следующих функций преобразует одиночный символ в его целочисленный эквивалент в Python?',
        tests_7: 'oct(x)',
        tests_8: 'ord(x)',
        tests_9: 'hex(x)',
        tests_10: 'unichr(x)',
        tests_11: 'Что из перечисленного эквивалентно random.randrange (3)?',
        tests_12: 'random.select(range(3))',
        tests_13: 'random.shuffle(range(3))',
        tests_14: 'random.choice(range(0, 3))',
        tests_15: 'range(3)',
        tests_16: 'Какое из перечисленных значений может возвращать функция random.randint (4)?',
        tests_17: '3,4',
        tests_18: '4',
        tests_19: 'error',
        tests_20: 'Ни один из вышеперечисленных',
        tests_21: 'Какой из следующих операторов в Python оценивается как истина, если он не находит переменную в указанной последовательности, и ложь в противном случае?',
        tests_22: 'not in',
        tests_23: 'is',
        tests_24: '//',
        tests_25: '**',
        tests_26: 'Какая из следующих функций используется для проверки, все ли символы в строке находятся в нижнем регистре?',
        tests_27: 'istitle()',
        tests_28: 'isspace()',
        tests_29: 'isnumeric()',
        tests_30: 'islower()',
        tests_31: 'Какая из следующих функций используется для проверки, все ли символы в строке являются десятичными?',
        tests_32: 'title()',
        tests_33: 'swapcase()',
        tests_34: 'isdecimal()',
        tests_35: 'upper()',
        tests_36: 'Какая из следующих переменных среды для Python является альтернативным путем поиска модуля?',
        tests_37: 'PYTHONHOME',
        tests_38: 'PYTHONCASEOK',
        tests_39: 'PYTHONSTARTUP',
        tests_40: 'PYTHONPATH',
        tests_41: 'Какая из следующих функций преобразует объект в строку в Python?',
        tests_42: 'str(x)',
        tests_43: 'float(x)',
        tests_44: 'long(x [,base] )',
        tests_45: 'int(x [,base])',
        tests_46: 'Какой оператор верный для power(x^y) ?',
        tests_47: 'X^^y',
        tests_48: 'X**y',
        tests_49: 'Х ^ у',
        tests_50: 'Ни один из вышеперечисленных',
        tests_51: 'Какой оператор осуществляет деление без остатка (возвращает целочисленное значение)?',
        tests_52: '%',
        tests_53: '//',
        tests_54: '/',
        tests_55: 'Ни один из вышеперечисленных',
        tests_56: 'Чувствителен ли Python к регистру при работе с идентификаторами?',
        tests_57: 'Да',
        tests_58: 'Нет',
        tests_59: 'Иногда',
        tests_60: 'Ни один из вышеперечисленных',
        tests_61: 'Какой ответ выдаст выражение 22 % 3',
        tests_62: '5',
        tests_63: '0',
        tests_64: '1',
        tests_65: '7',
        tests_66: 'Что возвращает int(math.pow(3, 2)) ?',
        tests_67: 'error, third argument required',
        tests_68: 'error, too many arguments',
        tests_69: '6',
        tests_70: '9',
        tests_71: 'Каково значение x, если x = math.sqrt(4) ?',
        tests_72: '2.0',
        tests_73: '2',
        tests_74: '(2.0, -2.0)',
        tests_75: 'Ничего из вышеперечисленного',
        tests_76: 'Предположим, d = {"john": 40, "peter": 45}, чтобы получить количество элементов в словаре, какую команду мы используем?',
        tests_77: 'd.len()',
        tests_78: 'size(d)',
        tests_79: 'len(d)',
        tests_80: 'd.size()',
        tests_81: 'Что из перечисленного является кортежем Python?',
        tests_82: '{}',
        tests_83: '{1, 2, 3}',
        tests_84: '[1, 2, 3]',
        tests_85: '(1, 2, 3)'
    }
}