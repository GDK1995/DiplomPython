export default {
    ru: {
        title_1: 'Ввод и вывод данных',
        text_1: 'Для печати значений в Питоне есть функция print(). Внутри круглых скобок через запятую мы пишем то, что хотим вывести. Вот программа, которая делает несколько вычислений: print(5 + 10)',
        text_1_1: 'Для ввода данных в программу мы используем функцию input(). Она считывает одну строку.',
        text_1_2: 'Вот программа, которая считывает имя пользователя и приветствует его: ',
        text_1_3: 'print("Как вас зовут?")',
        text_1_4: 'name = input()',
        text_1_5: 'print("Здравствуйте, " + name + "!")',
        text_1_6: 'Мы будем писать программы, которые считывают данные, перерабатывают их и выводят какой-то результат. При запуске на компьютере такие программы считывают данные, которые пользователь вводит с клавиатуры, а результат выводят на экран.',
        text_1_7: 'Попробуем написать программу, которая считывает два числа и выводит их сумму. Для этого считаем два числа и сохраним их в переменные a и b, пользуясь оператором присваивания =. Слева от оператора присваивания в программах на Питоне ставится имя переменной — например, строка из латинских букв. Справа от оператора присваивания ставится любое выражение. Имя станет указывать на результат вычисления выражения. Проиграйте эту программу и посмотрите на результаты её работы:',
        text_1_8: 'a = input()',
        text_1_9: 'b = input()',
        text_1_10: 's = a + b',
        text_1_11: 'print(s)',
        text_1_12: 'Мы видим, что программа выводит 57, хотя в реальной жизни 5 + 7 будет 12. Это произошло потому, что Питон в третьей строчке «сложил» две строки, а не два числа. В Питоне две строки складываются так: к первой строке приписывается вторая.',
        text_1_13: 'Обратите внимание, что в визуализаторе содержимое переменных a и b заключено в кавычки. Это означает, что в a и b лежат строки, а не числа.',
        text_1_14: 'В Питоне все данные называются объектами. Число 2 представляется объектом «число 2», строка "hello" – это объект «строка "hello"».',
        text_1_15: 'Каждый объект относится к какому-то типу. Строки хранятся в объектах типа str, целые числа хранятся в объектах типа int, дробные числа (вещественные числа) — в объектах типа float. Тип объекта определяет, какие действия можно делать с объектами этого типа.',
        chapter_2_1: 'Синтаксис условной инструкции',
        chapter_2_2: 'Вложенные условные инструкции',
        chapter_2_3: 'Операторы сравнения',
        chapter_2_4: 'Тип данных bool',
        chapter_2_5: 'Каскадные условные инструкции',
        title_2: 'Условия',
        text_2_1: 'Все ранее рассматриваемые программы имели линейную структуру: все инструкции выполнялись последовательно одна за одной, каждая записанная инструкция обязательно выполняется.',
        text_2_2: 'Внутри условных инструкций можно использовать любые инструкции языка Питон, в том числе и условную инструкцию. Получаем вложенное ветвление – после одной развилки в ходе исполнения программы появляется другая развилка. При этом вложенные блоки имеют больший размер отступа (например, 8 пробелов).',
        text_2_3: 'Операторы сравнения в Питоне можно объединять в цепочки (в отличии от большинства других языков программирования, где для этого нужно использовать логические связки',
        text_2_4: 'Операторы сравнения возвращают значения специального логического типа bool. Значения логического типа могут принимать одно из двух значений: True (истина) или False (ложь).',
        text_2_5: 'Если преобразовать логическое True к типу int, то получится 1, а преобразование False даст 0. При обратном преобразовании число 0 преобразуется в False, а любое ненулевое число в True. При преобразовании str в bool пустая строка преобразовывается в False, а любая непустая строка в True.',
        text_2_6: 'Допустим мы хотим по данному числу x определить его абсолютную величину (модуль). Программа должна напечатать значение переменной x, если x>0 или же величину -x в противном случае. Линейная структура программы нарушается: в зависимости от справедливости условия x>0 должна быть выведена одна или другая величина. Соответствующий фрагмент программы на Питоне имеет вид:',
        text_2_7: 'x = int(input())',
        text_2_8: 'if x > 0:',
        text_2_9: 'print(x)',
        text_2_10: 'else:',
        text_2_11: 'print(-x)',
        text_2_12: 'В этой программе используется условная инструкция if (если). После слова if указывается проверяемое условие (x > 0), завершающееся двоеточием. После этого идет блок (последовательность) инструкций, который будет выполнен, если условие истинно, в нашем примере это вывод на экран величины x. Затем идет слово else (иначе), также завершающееся двоеточием, и блок инструкций, который будет выполнен, если проверяемое условие неверно, в данном случае будет выведено значение -x.',
        text_2_13: 'Итак, условная инструкция в Питоне имеет следующий синтаксис:',
        text_2_14: 'if Условие:',
        text_2_15: 'Блок инструкций 1',
        text_2_16: 'else:',
        text_2_17: 'Блок инструкций 2',
        text_2_18: 'Блок инструкций 1 будет выполнен, если Условие истинно. Если Условие ложно, будет выполнен Блок инструкций 2.',
        text_2_19: 'Для выделения блока инструкций, относящихся к инструкции if или else в языке Питон используются отступы. Все инструкции, которые относятся к одному блоку, должны иметь равную величину отступа, то есть одинаковое число пробелов в начале строки. Рекомендуется использовать отступ в 4 пробела и не рекомедуется использовать в качестве отступа символ табуляции.',
        text_2_20: 'Это одно из существенных отличий синтаксиса Питона от синтаксиса большинства языков, в которых блоки выделяются специальными словами, например, нц... кц в Кумире, begin... end в Паскале или фигурными скобками в Си.',
        text_2_21: 'Покажем это на примере программы, которая по данным ненулевым числам x и y определяет, в какой из четвертей координатной плоскости находится точка (x,y):',
        text_2_22: 'В этом примере мы использовали комментарии – текст, который интерпретатор игнорирует. Комментариями в Питоне является символ # и весь текст после этого символа до конца строки.',
        text_2_23: 'Меньше — условие верно, если первый операнд меньше второго.',
        text_2_24: 'Больше — условие верно, если первый операнд больше второго.',
        text_2_25: 'Меньше или равно.',
        text_2_26: 'Больше или равно.',
        text_2_27: 'Равенство. Условие верно, если два операнда равны.',
        text_2_28: 'Неравенство. Условие верно, если два операнда неравны.',
        text_2_29: 'Например, условие (x * x < 1000) означает “значение x * x меньше 1000”, а условие (2 * x != y) означает “удвоенное значение переменной x не равно значению переменной y”.',
        text_2_30: 'Операторы сравнения в Питоне можно объединять в цепочки (в отличии от большинства других языков программирования, где для этого нужно использовать логические связки), например, a == b == c или 1 <= x <= 10.',
        text_2_31: 'Иногда нужно проверить одновременно не одно, а несколько условий. Например, проверить, является ли данное число четным можно при помощи условия (n % 2 == 0) (остаток от деления n на 2 равен 0), а если необходимо проверить, что два данных целых числа n и m являются четными, необходимо проверить справедливость обоих условий: n % 2 == 0 и m % 2 == 0, для чего их необходимо объединить при помощи оператора and (логическое И): n % 2 == 0 and m % 2 == 0.',
        text_2_32: 'В Питоне существуют стандартные логические операторы: логическое И, логическое ИЛИ, логическое отрицание.',
        text_2_33: 'Логическое И является бинарным оператором (то есть оператором с двумя операндами: левым и правым) и имеет вид and. Оператор and возвращает True тогда и только тогда, когда оба его операнда имеют значение True.',
        text_2_34: 'Логическое ИЛИ является бинарным оператором и возвращает True тогда и только тогда, когда хотя бы один операнд равен True. Оператор “логическое ИЛИ” имеет вид or.',
        text_2_35: 'Логическое НЕ (отрицание) является унарным (то есть с одним операндом) оператором и имеет вид not, за которым следует единственный операнд. Логическое НЕ возвращает True, если операнд равен False и наоборот.',
        text_2_36: 'Пример программы, определяющий четверть координатной плоскости, можно переписать используя “каскадную“ последовательность операцией if... elif... else:',
        text_2_37: 'В такой конструкции условия if, ..., elif проверяются по очереди, выполняется блок, соответствующий первому из истинных условий. Если все проверяемые условия ложны, то выполняется блок else, если он присутствует.',
        title_3: 'Вычисления',
        chapter_3_1: 'Целочисленная арифметика',
        chapter_3_2: 'Действительные числа',
        chapter_3_3: 'Библиотека math',
        text_3_1: 'Для целых чисел определены операции +, -, * и **. Операция деления / для целых чисел возвращает вещественное число (значение типа float). Также функция возведения в степень возвращает значение типа float, если показатель степени — отрицательное число.',
        text_3_2: 'В этом разделе речь пойдет о действительных числах, имеющих тип float. Обратите внимание, что если вы хотите считать с клавиатуры действительное число, то результат, возращаемый функцией input() необходимо преобразовывать к типу float:',
        text_3_3: 'Для проведения вычислений с действительными числами язык Питон содержит много дополнительных функций, собранных в библиотеку (модуль), которая называется math.',
        text_3_4: 'Но есть и специальная операция целочисленного деления, выполняющегося с отбрасыванием дробной части, которая обозначается // (она соответствует операции div в Паскале). Она возвращает целое число: целую часть частного. Другая близкая ей операция − это операция взятия остатка от деления, обозначаемая % (она соответствует операции mod в Паскале). Например:',
        text_3_5: 'print(17 / 3)   # выведет 5.66666666667',
        text_3_6: 'print(17 // 3)  # выведет 5',
        text_3_7: 'print(17 % 3)   # выведет 2',
        text_3_8: 'x = float(input())',
        text_3_9: 'print(x)',
        text_3_10: 'Действительные (вещественные) числа представляются в виде чисел с десятичной точкой (а не запятой, как принято при записи десятичных дробей в русских текстах). Для записи очень больших или очень маленьких по модулю чисел используется так называемая запись «с плавающей точкой» (также называемая «научная» запись). В этом случае число представляется в виде некоторой десятичной дроби, называемой мантиссой, умноженной на целочисленную степень десяти (порядок). Например, расстояние от Земли до Солнца равно 1.496·1011, а масса молекулы воды 2.99·10-23.',
        text_3_11: 'Числа с плавающей точкой в программах на языке Питон, а также при вводе и выводе записываются так: сначала пишется мантисса, затем пишется буква e, затем пишется порядок. Пробелы внутри этой записи не ставятся. Например, указанные выше константы можно записать в виде 1.496e11 и 2.99e-23. Перед самим числом также может стоять знак минус.',
        text_3_12: 'Напомним, что результатом операции деления / всегда является действительное число (float), в то время как результатом операции // является целое число (int).',
        text_3_13: 'Для использования этих функций в начале программы необходимо подключить математическую библиотеку, что делается командой',
        text_3_14: 'import math',
        text_3_15: 'Например, пусть мы хотим округлять вещественные числа до ближайшего целого числа вверх. Соответствующая функция ceil от одного аргумента вызывается, например, так: math.ceil(x) (то есть явно указывается, что из модуля math используется функция ceil). Вместо числа x может быть любое число, переменная или выражение.',
        title_4: 'Цикл for',
        chapter_4_1: 'Цикл for',
        chapter_4_2: 'Функция range',
        chapter_4_3: 'Настройка функции print()',
        text_4_1: 'Цикл for, также называемый циклом с параметром, в языке Питон богат возможностями. В цикле for указывается переменная и множество значений, по которому будет пробегать переменная. Множество значений может быть задано списком, кортежем, строкой или диапазоном.',
        text_4_2: 'Как правило, циклы for используются либо для повторения какой-либо последовательности действий заданное число раз, либо для изменения значения переменной в цикле от некоторого начального значения до некоторого конечного.',
        text_4_3: 'По умолчанию функция print() принимает несколько аргументов, выводит их через пробел, после чего ставит перевод строки. Это поведение можно изменить, используя именованные параметры sep (разделитель) и end (окончание).',
        text_4_4: 'print(4, 5, 6)',
        text_4_5: 'print()',
        text_4_6: 'Для повторения цикла некоторое заданное число раз n можно использовать цикл for вместе с функцией range:',
        text_4_7: 'for i in range(4):  # равносильно инструкции for i in 0, 1, 2, 3:',
        text_4_8: '# здесь можно выполнять циклические действия',
        text_4_9: 'print(i)',
        text_4_10: 'print(i ** 2)',
        text_4_11: '# цикл закончился, поскольку закончился блок с отступом',
        text_4_12: 'print("Конец цикла")',
        text_4_13: 'В качестве n может использоваться числовая константа, переменная или произвольное арифметическое выражение (например, 2 ** 10). Если значение n равно нулю или отрицательное, то тело цикла не выполнится ни разу.',
        text_4_14: 'Функция range может также принимать не один, а два параметра. Вызов range(a, b) означает, что индексная переменная будеть принимать значения от a до b - 1, то есть первый параметр функции range, вызываемой с двумя параметрами, задает начальное значение индексной переменной, а второй параметр — первое значение, которое индексная переменная принимать не будет.',
        text_4_15: 'Наконец, чтобы организовать цикл, в котором индексная переменная будет уменьшаться, необходимо использовать функцию range с тремя параметрами. Первый параметр задает начальное значение индексной переменной, второй параметр — значение, до которого будет изменяться индексная переменная (не включая его!), а третий параметр — величину изменения индексной переменной. Например, сделать цикл по всем нечетным числам от 1 до 99 можно при помощи функции range(1, 100, 2), а сделать цикл по всем числам от 100 до 1 можно при помощи range(100, 0, -1).',
        text_4_16: 'Вот простейший пример использования цикла, где в качестве множества значений используется кортеж:',
        text_4_17: 'Инструкция i += 1 эквивалентна конструкции i = i + 1 (это просто сокращенная запись). Такую сокращенную запись можно использовать для всех арифметических операций: *=, -=, /=, %=...',
        text_4_18: 'При первых трех итерациях цикла переменная i будет принимать значение типа int, при последующих трех — типа str.',
        title_5: 'Строки',
        chapter_5_1: 'Срезы (slices)',
        chapter_5_2: 'Методы',
        text_5_1: 'Строка считывается со стандартного ввода функцией input(). Напомним, что для двух строк определена операция сложения (конкатенации), также определена операция умножения строки на число.',
        text_5_2: 'Срез (slice) — извлечение из данной строки одного символа или некоторого фрагмента подстроки или подпоследовательности.',
        text_5_3: 'Метод — это функция, применяемая к объекту, в данном случае — к строке. Метод вызывается в виде Имя_объекта.Имя_метода(параметры). Например, S.find("e") — это применение к строке S метода find с одним параметром "e".',
        text_5_4: 'Строка состоит из последовательности символов. Узнать количество символов (длину строки) можно при помощи функции len.',
        text_5_5: 'Любой другой объект в Питоне можно перевести к строке, которая ему соответствует. Для этого нужно вызвать функцию str(), передав ей в качестве параметра объект, переводимый в строку.',
        text_5_6: 'На самом деле каждая строка, с точки зрения Питона, — это объект класса str. Чтобы получить по объекту другой объект другого класса, как-то ему соответствующий, можно использовать функцию приведения. Имя этой функции совпадает с именем класса, к которому мы приводим объект. (Для знатоков: эта функция — это конструктор объектов данного класса.) Пример: int — класс для целых чисел. Перевод строки в число осуществляется функцией int().',
        text_5_7: 'Заметим, что в Питоне нет отдельного типа для символов строки. Каждый объект, который получается в результате среза S[i] — это тоже строка типа str.',
        text_5_8: 'Номера символов в строке (а также в других структурах данных: списках, кортежах) называются индексом.',
        text_5_9: 'Срез с двумя параметрами: S[a:b] возвращает подстроку из b - a символов, начиная с символа c индексом a, то есть до символа с индексом b, не включая его. Например, S[1:4] == "ell", то же самое получится если написать S[-4:-1]. Можно использовать как положительные, так и отрицательные индексы в одном срезе, например, S[1:-1] — это строка без первого и последнего символа (срез начинается с символа с индексом 1 и заканчиватеся индексом -1, не включая его).',
        text_5_10: 'Если опустить второй параметр (но поставить двоеточие), то срез берется до конца строки. Например, чтобы удалить из строки первый символ (его индекс равен 0), можно взять срез S[1:]. Аналогично если опустить первый параметр, то можно взять срез от начала строки. То есть удалить из строки последний символ можно при помощи среза S[:-1]. Срез S[:] совпадает с самой строкой S.',
        text_5_11: 'Любые операции среза со строкой создают новые строки и никогда не меняют исходную строку. В Питоне строки вообще являются неизменяемыми, их невозможно изменить. Можно лишь в старую переменную присвоить новую строку.',
        text_5_12: 'На самом деле в питоне нет и переменных. Есть лишь имена, которые связаны с какими-нибудь объектами. Можно сначала связать имя с одним объектом, а потом — с другим. Можно несколько имён связать с одним и тем же объектом.',
        text_5_13: 'Если задать срез с тремя параметрами S[a:b:d], то третий параметр задает шаг, как в случае с функцией range, то есть будут взяты символы с индексами a, a + d, a + 2 * d и т. д. При задании значения третьего параметра, равному 2, в срез попадет кажый второй символ, а если взять значение среза, равное -1, то символы будут идти в обратном порядке. Например, можно перевернуть строку срезом S[::-1].',
        text_5_14: 'Метод find находит в данной строке (к которой применяется метод) данную подстроку (которая передается в качестве параметра). Функция возвращает индекс первого вхождения искомой подстроки. Если же подстрока не найдена, то метод возвращает значение -1.',
        text_5_15: 'Аналогично, метод rfind возвращает индекс последнего вхождения данной строки (“поиск справа”).',
        text_5_16: 'Если вызвать метод find с тремя параметрами S.find(T, a, b), то поиск будет осуществляться в срезе S[a:b]. Если указать только два параметра S.find(T, a), то поиск будет осуществляться в срезе S[a:], то есть начиная с символа с индексом a и до конца строки. Метод S.find(T, a, b) возращает индекс в строке S, а не индекс относительно среза.',
        text_5_17: 'Метод replace заменяет все вхождения одной строки на другую. Формат: S.replace(old, new) — заменить в строке S все вхождения подстроки old на подстроку new.',
        text_5_18: 'Подсчитывает количество вхождений одной строки в другую строку. Простейшая форма вызова S.count(T)  возвращает число вхождений строки T внутри строки S. ',
        title_6: 'Цикл while',
        text_6: '',
        title_7: 'Списки',
        text_7: '',
        title_8: 'Функции и рекурсия',
        text_8: '',
        title_9: 'Двумерные массивы',
        text_9: '',
        title_10: 'Множества',
        text_10: '',
        title_11: 'Словари',
        text_11: ''
    }
}